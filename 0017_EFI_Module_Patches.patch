Various patches to fix PKCS#7 sign of modules and more.
---

diff --git a/certs/internal.h b/certs/internal.h
new file mode 100644
index 000000000000..5dcbefb0c23a
--- /dev/null
+++ b/certs/internal.h
@@ -0,0 +1,18 @@
+/* Internal definitions
+ *
+ * Copyright (C) 2016 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+
+/*
+ * system_keyring.c
+ */
+#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
+extern void __init add_trusted_secondary_key(const char *source,
+					     const void *data, size_t len);
+#endif
diff --git a/certs/Kconfig b/certs/Kconfig
index 6ce51ede9e9b..630ae09bbea2 100644
--- a/certs/Kconfig
+++ b/certs/Kconfig
@@ -83,4 +83,28 @@ config SYSTEM_BLACKLIST_HASH_LIST
 	  wrapper to incorporate the list into the kernel.  Each <hash> should
 	  be a string of hex digits.
 
+config EFI_SIGNATURE_LIST_PARSER
+	bool "EFI signature list parser"
+	depends on EFI
+	select X509_CERTIFICATE_PARSER
+	help
+	  This option provides support for parsing EFI signature lists for
+	  X.509 certificates and turning them into keys.
+
+config LOAD_UEFI_KEYS
+       bool "Load certs and blacklist from UEFI db for module checking"
+       depends on SYSTEM_BLACKLIST_KEYRING
+       depends on SECONDARY_TRUSTED_KEYRING
+       depends on EFI
+       depends on EFI_SIGNATURE_LIST_PARSER
+       help
+         If the kernel is booted in secure boot mode, this option will cause
+         the kernel to load the certificates from the UEFI db and MokListRT
+         into the secondary trusted keyring.  It will also load any X.509
+         SHA256 hashes in the dbx list into the blacklist.
+
+         The effect of this is that, if the kernel is booted in secure boot
+         mode, modules signed with UEFI-stored keys will be permitted to be
+         loaded and keys that match the blacklist will be rejected.
+
 endmenu
diff --git a/certs/Makefile b/certs/Makefile
index 847361ce14d1..ffe871574056 100644
--- a/certs/Makefile
+++ b/certs/Makefile
@@ -10,6 +10,11 @@ obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist_hashes.o
 else
 obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist_nohashes.o
 endif
+obj-$(CONFIG_EFI_SIGNATURE_LIST_PARSER) += efi_parser.o
+
+obj-$(CONFIG_LOAD_UEFI_KEYS) += load_uefi.o
+$(obj)/load_uefi.o: KBUILD_CFLAGS += -fshort-wchar
+
 
 ifeq ($(CONFIG_SYSTEM_TRUSTED_KEYRING),y)
 
diff --git a/certs/load_uefi.c b/certs/load_uefi.c
new file mode 100644
index 000000000000..b44e464c3ff4
--- /dev/null
+++ b/certs/load_uefi.c
@@ -0,0 +1,192 @@
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/cred.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+#include <linux/slab.h>
+#include <keys/asymmetric-type.h>
+#include <keys/system_keyring.h>
+#include "internal.h"
+
+static __initdata efi_guid_t efi_cert_x509_guid = EFI_CERT_X509_GUID;
+static __initdata efi_guid_t efi_cert_x509_sha256_guid = EFI_CERT_X509_SHA256_GUID;
+static __initdata efi_guid_t efi_cert_sha256_guid = EFI_CERT_SHA256_GUID;
+
+/*
+ * Look to see if a UEFI variable called MokIgnoreDB exists and return true if
+ * it does.
+ *
+ * This UEFI variable is set by the shim if a user tells the shim to not use
+ * the certs/hashes in the UEFI db variable for verification purposes.  If it
+ * is set, we should ignore the db variable also and the true return indicates
+ * this.
+ */
+static __init bool uefi_check_ignore_db(void)
+{
+       efi_status_t status;
+       unsigned int db = 0;
+       unsigned long size = sizeof(db);
+       efi_guid_t guid = EFI_SHIM_LOCK_GUID;
+
+       status = efi.get_variable(L"MokIgnoreDB", &guid, NULL, &size, &db);
+       return status == EFI_SUCCESS;
+}
+
+/*
+ * Get a certificate list blob from the named EFI variable.
+ */
+static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,
+                                 unsigned long *size)
+{
+       efi_status_t status;
+       unsigned long lsize = 4;
+       unsigned long tmpdb[4];
+       void *db;
+
+       status = efi.get_variable(name, guid, NULL, &lsize, &tmpdb);
+       if (status != EFI_BUFFER_TOO_SMALL) {
+               pr_err("Couldn't get size: 0x%lx\n", status);
+               return NULL;
+       }
+
+       db = kmalloc(lsize, GFP_KERNEL);
+       if (!db) {
+               pr_err("Couldn't allocate memory for uefi cert list\n");
+               return NULL;
+       }
+
+       status = efi.get_variable(name, guid, NULL, &lsize, db);
+       if (status != EFI_SUCCESS) {
+               kfree(db);
+               pr_err("Error reading db var: 0x%lx\n", status);
+               return NULL;
+       }
+
+       *size = lsize;
+       return db;
+}
+
+/*
+ * Blacklist an X509 TBS hash.
+ */
+static __init void uefi_blacklist_x509_tbs(const char *source,
+                                          const void *data, size_t len)
+{
+       char *hash, *p;
+
+       hash = kmalloc(4 + len * 2 + 1, GFP_KERNEL);
+       if (!hash)
+               return;
+       p = memcpy(hash, "tbs:", 4);
+       p += 4;
+       bin2hex(p, data, len);
+       p += len * 2;
+       *p = 0;
+
+       mark_hash_blacklisted(hash);
+       kfree(hash);
+}
+
+/*
+ * Blacklist the hash of an executable.
+ */
+static __init void uefi_blacklist_binary(const char *source,
+                                        const void *data, size_t len)
+{
+       char *hash, *p;
+
+       hash = kmalloc(4 + len * 2 + 1, GFP_KERNEL);
+       if (!hash)
+               return;
+       p = memcpy(hash, "bin:", 4);
+       p += 4;
+       bin2hex(p, data, len);
+       p += len * 2;
+       *p = 0;
+
+       mark_hash_blacklisted(hash);
+       kfree(hash);
+}
+
+/*
+ * Return the appropriate handler for particular signature list types found in
+ * the UEFI db and MokListRT tables.
+ */
+static __init efi_element_handler_t get_handler_for_db(const efi_guid_t *sig_type)
+{
+       if (efi_guidcmp(*sig_type, efi_cert_x509_guid) == 0)
+               return add_trusted_secondary_key;
+       return 0;
+}
+
+/*
+ * Return the appropriate handler for particular signature list types found in
+ * the UEFI dbx and MokListXRT tables.
+ */
+static __init efi_element_handler_t get_handler_for_dbx(const efi_guid_t *sig_type)
+{
+       if (efi_guidcmp(*sig_type, efi_cert_x509_sha256_guid) == 0)
+               return uefi_blacklist_x509_tbs;
+       if (efi_guidcmp(*sig_type, efi_cert_sha256_guid) == 0)
+               return uefi_blacklist_binary;
+       return 0;
+}
+
+/*
+ * Load the certs contained in the UEFI databases into the secondary trusted
+ * keyring and the UEFI blacklisted X.509 cert SHA256 hashes into the blacklist
+ * keyring.
+ */
+static int __init load_uefi_certs(void)
+{
+       efi_guid_t secure_var = EFI_IMAGE_SECURITY_DATABASE_GUID;
+       efi_guid_t mok_var = EFI_SHIM_LOCK_GUID;
+       void *db = NULL, *dbx = NULL, *mok = NULL;
+       unsigned long dbsize = 0, dbxsize = 0, moksize = 0;
+       int rc = 0;
+
+       if (!efi.get_variable)
+               return false;
+
+       /* Get db, MokListRT, and dbx.  They might not exist, so it isn't
+        * an error if we can't get them.
+        */
+       if (!uefi_check_ignore_db()) {
+               db = get_cert_list(L"db", &secure_var, &dbsize);
+               if (!db) {
+                       pr_err("MODSIGN: Couldn't get UEFI db list\n");
+               } else {
+                       rc = parse_efi_signature_list("UEFI:db",
+                                                     db, dbsize, get_handler_for_db);
+                       if (rc)
+                               pr_err("Couldn't parse db signatures: %d\n", rc);
+                       kfree(db);
+               }
+       }
+
+       mok = get_cert_list(L"MokListRT", &mok_var, &moksize);
+       if (!mok) {
+               pr_info("MODSIGN: Couldn't get UEFI MokListRT\n");
+       } else {
+               rc = parse_efi_signature_list("UEFI:MokListRT",
+                                             mok, moksize, get_handler_for_db);
+               if (rc)
+                       pr_err("Couldn't parse MokListRT signatures: %d\n", rc);
+               kfree(mok);
+       }
+
+       dbx = get_cert_list(L"dbx", &secure_var, &dbxsize);
+       if (!dbx) {
+               pr_info("MODSIGN: Couldn't get UEFI dbx list\n");
+       } else {
+               rc = parse_efi_signature_list("UEFI:dbx",
+                                             dbx, dbxsize,
+                                             get_handler_for_dbx);
+               if (rc)
+                       pr_err("Couldn't parse dbx signatures: %d\n", rc);
+               kfree(dbx);
+       }
+
+       return rc;
+}
+late_initcall(load_uefi_certs);
diff --git a/certs/system_keyring.c b/certs/system_keyring.c
index 8172871..3abe7ba 100644
--- a/certs/system_keyring.c
+++ b/certs/system_keyring.c
@@ -19,6 +19,7 @@
 #include <keys/asymmetric-type.h>
 #include <keys/system_keyring.h>
 #include <crypto/pkcs7.h>
+#include "internal.h"
 
 static struct key *builtin_trusted_keys;
 #ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
@@ -175,6 +176,7 @@ static __init int load_system_certificate_list(void)
 		if (IS_ERR(key)) {
 			pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
 			       PTR_ERR(key));
+                        WARN_ON_ONCE(1);
 		} else {
 			pr_notice("Loaded X.509 cert '%s'\n",
 				  key_ref_to_ptr(key)->description);
@@ -287,3 +289,35 @@ error:
 	platform_trusted_keys = keyring;
 }
 #endif
+
+#ifdef CONFIG_SECONDARY_TRUSTED_KEYRING
+/**
+ * add_trusted_secondary_key - Add to secondary keyring with no validation
+ * @source: Source of key
+ * @data: The blob holding the key
+ * @len: The length of the data blob
+ *
+ * Add a key to the secondary keyring without checking its trust chain.  This
+ * is available only during kernel initialisation.
+ */
+void __init add_trusted_secondary_key(const char *source,
+				      const void *data, size_t len)
+{
+	key_ref_t key;
+
+	key = key_create_or_update(make_key_ref(secondary_trusted_keys, 1),
+				   "asymmetric",
+				   NULL, data, len,
+				   (KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				   KEY_USR_VIEW,
+				   KEY_ALLOC_NOT_IN_QUOTA |
+				   KEY_ALLOC_BYPASS_RESTRICTION);
+
+	if (IS_ERR(key))
+		pr_err("Problem loading %s X.509 certificate (%ld)\n",
+		       source, PTR_ERR(key));
+	else
+		pr_notice("Loaded %s cert '%s' linked to secondary sys keyring\n",
+			  source, key_ref_to_ptr(key)->description);
+}
+#endif /* CONFIG_SECONDARY_TRUSTED_KEYRING */
diff --git a/certs/efi_parser.c b/certs/efi_parser.c
new file mode 100644
index 000000000000..4e396f98f5c7
--- /dev/null
+++ b/certs/efi_parser.c
--- linux-5.0/certs/efi_parser.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-5.0_WORK/certs/efi_parser.c	2019-03-06 20:49:36.799957373 +0100
@@ -0,0 +1,108 @@
+// SPDX-License-Identifier: GPL-2.0+
+/* EFI signature/key/certificate list parser
+ *
+ * Copyright (C) 2012, 2016 Red Hat, Inc. All Rights Reserved.
+ * Written by David Howells (dhowells@redhat.com)
+ */
+
+#define pr_fmt(fmt) "EFI: "fmt
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/err.h>
+#include <linux/efi.h>
+
+/**
+ * parse_efi_signature_list - Parse an EFI signature list for certificates
+ * @source: The source of the key
+ * @data: The data blob to parse
+ * @size: The size of the data blob
+ * @get_handler_for_guid: Get the handler func for the sig type (or NULL)
+ *
+ * Parse an EFI signature list looking for elements of interest.  A list is
+ * made up of a series of sublists, where all the elements in a sublist are of
+ * the same type, but sublists can be of different types.
+ *
+ * For each sublist encountered, the @get_handler_for_guid function is called
+ * with the type specifier GUID and returns either a pointer to a function to
+ * handle elements of that type or NULL if the type is not of interest.
+ *
+ * If the sublist is of interest, each element is passed to the handler
+ * function in turn.
+ *
+ * Error EBADMSG is returned if the list doesn't parse correctly and 0 is
+ * returned if the list was parsed correctly.  No error can be returned from
+ * the @get_handler_for_guid function or the element handler function it
+ * returns.
+ */
+int __init parse_efi_signature_list(
+	const char *source,
+	const void *data, size_t size,
+	efi_element_handler_t (*get_handler_for_guid)(const efi_guid_t *))
+{
+	efi_element_handler_t handler;
+	unsigned int offs = 0;
+
+	pr_devel("-->%s(,%zu)\n", __func__, size);
+
+	while (size > 0) {
+		const efi_signature_data_t *elem;
+		efi_signature_list_t list;
+		size_t lsize, esize, hsize, elsize;
+
+		if (size < sizeof(list))
+			return -EBADMSG;
+
+		memcpy(&list, data, sizeof(list));
+		pr_devel("LIST[%04x] guid=%pUl ls=%x hs=%x ss=%x\n",
+			 offs,
+			 list.signature_type.b, list.signature_list_size,
+			 list.signature_header_size, list.signature_size);
+
+		lsize = list.signature_list_size;
+		hsize = list.signature_header_size;
+		esize = list.signature_size;
+		elsize = lsize - sizeof(list) - hsize;
+
+		if (lsize > size) {
+			pr_devel("<--%s() = -EBADMSG [overrun @%x]\n",
+				 __func__, offs);
+			return -EBADMSG;
+		}
+
+		if (lsize < sizeof(list) ||
+		    lsize - sizeof(list) < hsize ||
+		    esize < sizeof(*elem) ||
+		    elsize < esize ||
+		    elsize % esize != 0) {
+			pr_devel("- bad size combo @%x\n", offs);
+			return -EBADMSG;
+		}
+
+		handler = get_handler_for_guid(&list.signature_type);
+		if (!handler) {
+			data += lsize;
+			size -= lsize;
+			offs += lsize;
+			continue;
+		}
+
+		data += sizeof(list) + hsize;
+		size -= sizeof(list) + hsize;
+		offs += sizeof(list) + hsize;
+
+		for (; elsize > 0; elsize -= esize) {
+			elem = data;
+
+			pr_devel("ELEM[%04x]\n", offs);
+			handler(source,
+				&elem->signature_data,
+				esize - sizeof(*elem));
+
+			data += esize;
+			size -= esize;
+			offs += esize;
+		}
+	}
+
+	return 0;
+}
diff --git a/security/integrity/Makefile b/security/integrity/Makefile
index 86df9ab..2288b49 100644
--- a/security/integrity/Makefile
+++ b/security/integrity/Makefile
@@ -10,7 +10,6 @@ integrity-$(CONFIG_INTEGRITY_AUDIT) += integrity_audit.o
 integrity-$(CONFIG_INTEGRITY_SIGNATURE) += digsig.o
 integrity-$(CONFIG_INTEGRITY_ASYMMETRIC_KEYS) += digsig_asymmetric.o
 integrity-$(CONFIG_INTEGRITY_PLATFORM_KEYRING) += platform_certs/platform_keyring.o \
-						  platform_certs/efi_parser.o \
 						  platform_certs/load_uefi.o
 obj-$(CONFIG_LOAD_UEFI_KEYS) += platform_certs/load_uefi.o
 $(obj)/load_uefi.o: KBUILD_CFLAGS += -fshort-wchar
diff --git a/security/integrity/platform_certs/load_uefi.c b/security/integrity/platform_certs/load_uefi.c
index 81b19c5..5c79486 100644
--- a/security/integrity/platform_certs/load_uefi.c
+++ b/security/integrity/platform_certs/load_uefi.c
@@ -38,8 +38,8 @@ static __init bool uefi_check_ignore_db(void)
 /*
  * Get a certificate list blob from the named EFI variable.
  */
-static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,
-				  unsigned long *size)
+static __init int get_cert_list(efi_char16_t *name, efi_guid_t *guid,
+				  unsigned long *size , void **cert_list)
 {
 	efi_status_t status;
 	unsigned long lsize = 4;
@@ -47,6 +47,12 @@ static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,
 	void *db;
 
 	status = efi.get_variable(name, guid, NULL, &lsize, &tmpdb);
+	if (status == EFI_NOT_FOUND) {
+		*size = 0;
+		*cert_list = NULL;
+		return 0;
+	}
+
 	if (status != EFI_BUFFER_TOO_SMALL) {
 		pr_err("Couldn't get size: 0x%lx\n", status);
 		return NULL;
@@ -54,7 +60,7 @@ static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,
 
 	db = kmalloc(lsize, GFP_KERNEL);
 	if (!db)
-		return NULL;
+		return -ENOMEM;
 
 	status = efi.get_variable(name, guid, NULL, &lsize, db);
 	if (status != EFI_SUCCESS) {
@@ -64,7 +70,8 @@ static __init void *get_cert_list(efi_char16_t *name, efi_guid_t *guid,
 	}
 
 	*size = lsize;
-	return db;
+	*cert_list = db;
+	return 0;
 }
 
 /*
@@ -153,10 +160,10 @@ static int __init load_uefi_certs(void)
 	 * an error if we can't get them.
 	 */
 	if (!uefi_check_ignore_db()) {
-		db = get_cert_list(L"db", &secure_var, &dbsize);
-		if (!db) {
+		rc = get_cert_list(L"db", &secure_var, &dbsize, &db);
+		if (rc < 0) {
 			pr_err("MODSIGN: Couldn't get UEFI db list\n");
-		} else {
+		} else if (dbsize != 0) {
 			rc = parse_efi_signature_list("UEFI:db",
 					db, dbsize, get_handler_for_db);
 			if (rc)
@@ -166,10 +173,10 @@ static int __init load_uefi_certs(void)
 		}
 	}
 
-	mok = get_cert_list(L"MokListRT", &mok_var, &moksize);
-	if (!mok) {
+	rc = get_cert_list(L"MokListRT", &mok_var, &moksize, &mok);
+	if (rc < 0) {
 		pr_info("Couldn't get UEFI MokListRT\n");
-	} else {
+	} else if (moksize != 0) {
 		rc = parse_efi_signature_list("UEFI:MokListRT",
 					      mok, moksize, get_handler_for_db);
 		if (rc)
@@ -177,10 +184,10 @@ static int __init load_uefi_certs(void)
 		kfree(mok);
 	}
 
-	dbx = get_cert_list(L"dbx", &secure_var, &dbxsize);
-	if (!dbx) {
+	rc = get_cert_list(L"dbx", &secure_var, &dbxsize, &dbx);
+	if (rc < 0) {
 		pr_info("Couldn't get UEFI dbx list\n");
-	} else {
+	} else if (dbxsize != 0) {
 		rc = parse_efi_signature_list("UEFI:dbx",
 					      dbx, dbxsize,
 					      get_handler_for_dbx);
--
1.0
