From d7904a9cb82457969a2de5c779832b4a678c25d1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Sveinar=20S=C3=B8pler?= <cybermax@dexter.no>
Date: Fri, 28 Aug 2020 09:28:41 +0200
Subject: [PATCH] PDS Fixup

---
 include/uapi/linux/sched.h |  2 +-
 init/Kconfig               |  2 +-
 kernel/sched/Makefile      |  2 +-
 kernel/sched/pds.c         | 17 ++++++++++++++++-
 4 files changed, 19 insertions(+), 4 deletions(-)

diff --git a/include/uapi/linux/sched.h b/include/uapi/linux/sched.h
index f692642cf..1c92ad96d 100644
--- a/include/uapi/linux/sched.h
+++ b/include/uapi/linux/sched.h
@@ -115,8 +115,8 @@ struct clone_args {
 #define SCHED_FIFO		1
 #define SCHED_RR		2
 #define SCHED_BATCH		3
-/* SCHED_ISO: Implemented in BFS/MuQSSPDS only */
 
+/* SCHED_ISO: Implemented in BFS/MuQSS/PDS only */
 #define SCHED_ISO		4
 
 #define SCHED_IDLE		5
diff --git a/init/Kconfig b/init/Kconfig
index 17651c24e..0b66026ed 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -760,6 +760,7 @@ menu "Scheduler features"
 config UCLAMP_TASK
 	bool "Enable utilization clamping for RT/FAIR tasks"
 	depends on CPU_FREQ_GOV_SCHEDUTIL
+	depends on !SCHED_PDS
 	help
 	  This feature enables the scheduler to track the clamped utilization
 	  of each CPU based on RUNNABLE tasks scheduled on that CPU.
@@ -1061,7 +1062,6 @@ config CGROUP_DEVICE
 
 config CGROUP_CPUACCT
 	bool "Simple CPU accounting controller"
-	depends on !SCHED_PDS
 	help
 	  Provides a simple controller for monitoring the
 	  total CPU consumed by the tasks in a cgroup.
diff --git a/kernel/sched/Makefile b/kernel/sched/Makefile
index 1b5bc273e..634295ae2 100644
--- a/kernel/sched/Makefile
+++ b/kernel/sched/Makefile
@@ -30,13 +30,13 @@ obj-y += fair.o rt.o deadline.o
 obj-$(CONFIG_SMP) += cpudeadline.o topology.o stop_task.o
 obj-$(CONFIG_SCHED_AUTOGROUP) += autogroup.o
 obj-$(CONFIG_SCHED_DEBUG) += debug.o
-obj-$(CONFIG_CGROUP_CPUACCT) += cpuacct.o
 endif
 obj-y += loadavg.o clock.o cputime.o
 obj-y += idle.o
 obj-y += wait.o wait_bit.o swait.o completion.o
 obj-$(CONFIG_SMP) += cpupri.o pelt.o
 obj-$(CONFIG_SCHEDSTATS) += stats.o
+obj-$(CONFIG_CGROUP_CPUACCT) += cpuacct.o
 obj-$(CONFIG_CPU_FREQ) += cpufreq.o
 obj-$(CONFIG_CPU_FREQ_GOV_SCHEDUTIL) += cpufreq_schedutil.o
 obj-$(CONFIG_MEMBARRIER) += membarrier.o
diff --git a/kernel/sched/pds.c b/kernel/sched/pds.c
index 6d426edef..926fce029 100644
--- a/kernel/sched/pds.c
+++ b/kernel/sched/pds.c
@@ -83,6 +83,18 @@ enum {
 	NR_CPU_AFFINITY_CHK_LEVEL
 };
 
+/*
+ * This allows printing both to /proc/sched_debug and
+ * to the console
+ */
+#define SEQ_printf(m, x...)			\
+ do {						\
+	if (m)					\
+		seq_printf(m, x);		\
+	else					\
+		pr_cont(x);			\
+ } while (0)
+
 static inline void print_scheduler_version(void)
 {
 	printk(KERN_INFO "pds: PDS-mq CPU Scheduler 0.99o by Alfred Chen and kept alive artificially by Tk-Glitch.\n");
@@ -6477,7 +6489,10 @@ void ia64_set_curr_task(int cpu, struct task_struct *p)
 #ifdef CONFIG_SCHED_DEBUG
 void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 			  struct seq_file *m)
-{}
+{
+	SEQ_printf(m, "%s (%d, #threads: %d)\n", p->comm, task_pid_nr_ns(p, ns),
+						get_nr_threads(p));
+}
 
 void proc_sched_set_task(struct task_struct *p)
 {}
-- 
2.17.1

